

---

## 一、订单簿预测市场的「统一盘口」设计图

**目标：**

* 底层：YES / NO 各自一套订单簿（和现有撮合系统兼容）
* 上层：给用户展示的是一个**统一事件盘口**：

  * 买「会发生」
  * 卖「会发生」
  * 买「不会发生」
  * 卖「不会发生」

### 1. 结构示意（逻辑图）

```text
                 ┌────────────────────────┐
                 │   Event Market View    │   ← 用户只看到这一层
                 │  事件：BTC>100k？      │
                 │                        │
                 │  Bid/Ask (HAPPEN)      │
                 │  Bid/Ask (NOT HAPPEN)  │
                 └─────────┬──────────────┘
                           │ 智能路由 + 映射
           ┌───────────────┴─────────────────┐
           │                                   │
┌──────────────────────┐           ┌──────────────────────┐
│ YES Contract Orderbook│          │  NO Contract Orderbook│
│ 合约：BTC>100k-YES    │          │ 合约：BTC>100k-NO     │
│  买单/卖单            │          │  买单/卖单             │
└──────────────────────┘          └──────────────────────┘
```

### 2. 用户视角的「统一盘口」

统一盘口可以长这样（对用户）：

```text
事件：BTC 在 12/31 前是否 > 100k？

[会发生 HAPPEN]
  买盘(Bid)：价格/数量      实际走向
   0.62   300              → YES, BUY
   0.60  1000              → YES, BUY

  卖盘(Ask)：
   0.65   200              → YES, SELL
   0.68   500              → YES, SELL

[不会发生 NOT HAPPEN]
  买盘(Bid)：
   0.38   600              → NO, BUY
   0.35  1200              → NO, BUY

  卖盘(Ask)：
   0.40   300              → NO, SELL
   0.42   800              → NO, SELL
```

**底层映射关系：**

* 区块「会发生」

  * 买 = BUY YES
  * 卖 = SELL YES
* 区块「不会发生」

  * 买 = BUY NO
  * 卖 = SELL NO

也可以只展示「会发生」一边，另一边用隐含价格 `1 - P_yes` 衍生出来（更接近 AMM 体验）。

---

## 二、YES/NO 智能路由逻辑（伪代码 + 简单公式）

### 1. 基本映射逻辑

先定义：

```text
Event e:
  - yes_contract_id
  - no_contract_id
```

统一接口（给前端）：

```text
placePredictionOrder(
    event_id,
    direction,   // HAPPEN / NOT_HAPPEN
    side,        // BUY / SELL
    price,
    quantity
)
```

#### 路由伪代码（最基础版）

```pseudo
function placePredictionOrder(eventId, direction, side, price, quantity, userId):
    event = loadEvent(eventId)

    if direction == HAPPEN:
        contractId = event.yes_contract_id
    else if direction == NOT_HAPPEN:
        contractId = event.no_contract_id
    else:
        throw "invalid direction"

    // side BUY/SELL 直接沿用
    order = {
        user_id: userId,
        contract_id: contractId,
        side: side,         // BUY / SELL
        price: price,       // 0~1 之间的 USDC 价格
        quantity: quantity, // 张数，每张上限 1 USDC
        type: LIMIT
    }

    sendToMatchingEngine(order)
```

**核心点：**
统一预测接口 → 映射到 YES / NO 具体合约 → 丢给你现有的撮合引擎。

---

### 2. 展示隐含价格（YES/NO 互推）

如果你希望统一盘口只显示 YES 价格，同时给出 NO 的隐含信息：

```text
P_yes_best = YES 市场当前最优价（例如 best_ask 或 mid）
P_no_implied = 1 - P_yes_best
```

或者更严格一点，加一个边际 ε：

```text
P_no_implied = max(0, 1 - P_yes_best - ε)
```

> ε 是给套利者留一点空间，避免理论上死锁。

---

### 3. （可选进阶）跨簿套利/对冲的路由逻辑

如果你希望系统自动「聪明一点」：

**目标：**
用户下单时，优先吃掉「另一边明显错价」的 liquidity，让系统帮用户自动套利。

示例：用户想买「不会发生」（NO, BUY）：

```pseudo
function routeBuyNotHappen(eventId, price, qty, userId):
    event = loadEvent(eventId)
    yesBook = getOrderbook(event.yes_contract_id)
    noBook  = getOrderbook(event.no_contract_id)

    // 1. 先看 NO 订单簿能否直接吃单
    bestNoAsk = noBook.bestAsk()  // NO 的最优卖价

    if bestNoAsk <= price:
        // 直接在 NO 簿成交 (taker)
        matchInOrderbook(noBook, BUY, price, qty, userId)
        return

    // 2. 看 YES 是否明显错价，例如 YES+NO > 1 的情况
    bestYesBid = yesBook.bestBid()

    // 强套利条件（例子，实际可调）：
    if bestYesBid + price > 1 + epsilon:
        // 系统可以作为中间商做一笔锁定套利
        // (用户买 NO @ price，系统在 YES 簿卖出或买入对冲)
        syntheticArbTrade(userId, event, price, qty)
        return

    // 3. 否则，挂为 NO 的买单
    placeLimitOrder(event.no_contract_id, BUY, price, qty, userId)
```

这部分可以根据你愿不愿意让「系统扮演做市商」来决定，要不要实现。
你也可以完全不做跨簿自动套利，而是放给专业用户做。

---

## 三、CLOB 下的预测事件产品结构（数据库表）

下面给一套可直接用的 SQL 表结构（偏交易所风格），你可以融合进你现有撮合系统。

### 1. 事件表：`t_event`

```sql
CREATE TABLE t_event (
    id               BIGSERIAL PRIMARY KEY,
    symbol           VARCHAR(64) NOT NULL,  -- 例如 BTC100K-20251231
    title            VARCHAR(255) NOT NULL, -- 展示标题
    description      TEXT,
    base_asset       VARCHAR(32) NOT NULL DEFAULT 'USDC',

    start_trading_at TIMESTAMP NOT NULL,    -- 开盘时间
    end_trading_at   TIMESTAMP NOT NULL,    -- 停盘时间（事件开始前）
    resolve_at       TIMESTAMP,             -- 预期结算时间

    status           VARCHAR(32) NOT NULL,  -- PENDING/OPEN/RESOLVING/SETTLED/CANCELED
    result           VARCHAR(16),           -- YES/NO/INVALID/UNRESOLVED

    yes_contract_id  BIGINT,                -- 方便查询
    no_contract_id   BIGINT,

    oracle_source    VARCHAR(64),           -- 预言机来源，如 "admin", "chainlink"
    oracle_ref       VARCHAR(128),          -- 外部ID、URL等

    created_at       TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at       TIMESTAMP NOT NULL DEFAULT NOW()
);
```

---

### 2. 合约表（YES/NO 合约）：`t_contract`

```sql
CREATE TABLE t_contract (
    id             BIGSERIAL PRIMARY KEY,
    event_id       BIGINT NOT NULL REFERENCES t_event(id),

    side           VARCHAR(8) NOT NULL,     -- 'YES' 或 'NO'
    symbol         VARCHAR(64) NOT NULL,    -- 如 BTC100K-20251231-YES
    display_name   VARCHAR(128),            -- 前端展示名

    tick_size      NUMERIC(18,8) NOT NULL DEFAULT 0.01,  -- 价格精度
    min_qty        NUMERIC(18,8) NOT NULL DEFAULT 1,
    max_qty        NUMERIC(18,8),

    maker_fee_rate NUMERIC(10,8) NOT NULL DEFAULT 0.0002,
    taker_fee_rate NUMERIC(10,8) NOT NULL DEFAULT 0.0005,

    status         VARCHAR(32) NOT NULL DEFAULT 'OPEN',  -- OPEN/PAUSED/SETTLED
    settlement_price NUMERIC(18,8),        -- 1, 0 或 0.5（INVALID）

    created_at     TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at     TIMESTAMP NOT NULL DEFAULT NOW()
);
```

> 对一个事件，会有两条记录：
> `side='YES'` 和 `side='NO'`。
> `event.yes_contract_id` / `event.no_contract_id` 指向它们。

---

### 3. 订单表：`t_order`

你可以直接沿用现有撮合系统的 order 表，这里给个通用版：

```sql
CREATE TABLE t_order (
    id               BIGSERIAL PRIMARY KEY,
    client_order_id  VARCHAR(64),                 -- 前端生成，选填
    user_id          BIGINT NOT NULL,

    contract_id      BIGINT NOT NULL REFERENCES t_contract(id),

    side             VARCHAR(4) NOT NULL,         -- 'BUY' / 'SELL'
    type             VARCHAR(16) NOT NULL,        -- 'LIMIT'/'MARKET' 等
    time_in_force    VARCHAR(16) NOT NULL DEFAULT 'GTC',

    price            NUMERIC(18,8),               -- LIMIT单有效
    quantity         NUMERIC(18,8) NOT NULL,      -- 下单总量
    filled_quantity  NUMERIC(18,8) NOT NULL DEFAULT 0,
    avg_fill_price   NUMERIC(18,8),

    status           VARCHAR(16) NOT NULL,        -- NEW/PARTIAL/FILLED/CANCELED/REJECTED

    created_at       TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at       TIMESTAMP NOT NULL DEFAULT NOW()
);
```

---

### 4. 成交表：`t_trade`

```sql
CREATE TABLE t_trade (
    id               BIGSERIAL PRIMARY KEY,
    contract_id      BIGINT NOT NULL REFERENCES t_contract(id),

    taker_order_id   BIGINT NOT NULL REFERENCES t_order(id),
    maker_order_id   BIGINT NOT NULL REFERENCES t_order(id),

    taker_user_id    BIGINT NOT NULL,
    maker_user_id    BIGINT NOT NULL,

    price            NUMERIC(18,8) NOT NULL,
    quantity         NUMERIC(18,8) NOT NULL,
    taker_side       VARCHAR(4) NOT NULL,         -- BUY/SELL

    taker_fee        NUMERIC(18,8) NOT NULL DEFAULT 0,
    maker_fee        NUMERIC(18,8) NOT NULL DEFAULT 0,

    created_at       TIMESTAMP NOT NULL DEFAULT NOW()
);
```

---

### 5. 持仓/仓位表：`t_position`

```sql
CREATE TABLE t_position (
    id               BIGSERIAL PRIMARY KEY,
    user_id          BIGINT NOT NULL,
    contract_id      BIGINT NOT NULL REFERENCES t_contract(id),

    quantity         NUMERIC(18,8) NOT NULL,      -- 持有张数, BUY 为正, SELL 可以视为负或保持独立字段
    avg_entry_price  NUMERIC(18,8) NOT NULL DEFAULT 0,

    realized_pnl     NUMERIC(18,8) NOT NULL DEFAULT 0,

    updated_at       TIMESTAMP NOT NULL DEFAULT NOW(),

    UNIQUE (user_id, contract_id)
);
```

---

### 6. 结算记录表：`t_event_settlement`

```sql
CREATE TABLE t_event_settlement (
    id               BIGSERIAL PRIMARY KEY,
    event_id         BIGINT NOT NULL REFERENCES t_event(id),
    result           VARCHAR(16) NOT NULL,       -- YES/NO/INVALID
    resolved_at      TIMESTAMP NOT NULL,
    tx_hash          VARCHAR(128),              -- 若链上结算，可存交易哈希
    note             TEXT
);
```

结算时：

1. 更新 `t_event.result` / `t_contract.settlement_price`（YES=1, NO=0 或反之）
2. 遍历 `t_position` 按持仓发放结算资金（USDC）
3. 记录一条 `t_event_settlement`

---

## 小结

你要的三块现在已经成型：

1. **统一盘口设计图**

   * 用户只看到「事件盘口」，底层 YES/NO 各一套订单簿
   * 智能路由负责把预测指令翻译为具体合约订单

2. **YES/NO 智能路由逻辑（伪代码+公式）**

   * `direction(HAPPEN/NOT_HAPPEN)` → `yes_contract_id/no_contract_id`
   * 支持扩展到跨簿套利/系统做市

3. **CLOB 下预测事件产品结构（SQL 表）**

   * `t_event` 事件
   * `t_contract` YES/NO 合约
   * `t_order` / `t_trade` / `t_position` / `t_event_settlement`

---

如果你愿意，下一步我可以帮你做其中任意一个的「**代码级实现**」：

* 用 **Go** 写一个极简撮合引擎（内存订单簿 + 预测事件支持）
* 或者直接帮你把这些 SQL + 路由逻辑整合进你现在的撮合/钱包/清算系统设计里。

你下一步想先搞：**撮合引擎 demo** 还是 **结算/清算流程设计**？




好，我们来把你要的东西搭成一整套“**单 YES 订单簿 + NO 镜像**”的伪代码架构：

* ✅ 下单（统一预测入口 → YES 单簿路由 + 镜像）
* ✅ 持仓查询（YES/NO 都能查）
* ✅ 结算（事件结果 YES / NO）

我用接近 Go/Java 风格的伪代码写，方便你直接改造成真实代码。

---

## 一、核心思想 & 映射总表（一定要先记住这个）

我们只维护 **一个订单簿：YES 合约**，NO 不在簿上，NO 是由 YES 镜像出来的“合成品”。

统一预测接口对用户暴露：

* `direction`:

  * `HAPPEN`   → 事件会发生（YES）
  * `NOT_HAPPEN` → 事件不会发生（NO）
* `side`:

  * `BUY` / `SELL`
* `price`: 用户认为这边 1 美元赔率的价格（0~1）
* `qty`: 张数（每张结算时上限 1 USDC）

**核心映射：**

| 用户下单含义                   | 对应资产 | 对应 YES 簿里的“镜像操作”         |
| ------------------------ | ---- | ------------------------ |
| HAPPEN + BUY  （买事件会发生）   | YES  | 在 YES 簿 `BUY` @ `p_yes`  |
| HAPPEN + SELL （卖事件会发生）   | YES  | 在 YES 簿 `SELL` @ `p_yes` |
| NOT_HAPPEN + BUY（买不会发生）  | NO   | 在 YES 簿按「镜像价格」下单         |
| NOT_HAPPEN + SELL（卖不会发生） | NO   | 在 YES 簿按「镜像价格」下单         |

镜像价格在概念上就是：

```text
p_yes = 1 - p_no
p_no  = 1 - p_yes
```

**简化做法：**

* YES 这边的匹配 & 撮合完全照普通现货，
* 你在 **“风控/记账层”用镜像换回 NO 的价格和持仓**。

---

## 二、数据结构设计（事件 & 持仓部分）

### 1. 事件 & 合约（简化）

```pseudo
enum EventResult { UNKNOWN, YES, NO }

struct Event {
    eventId:   long
    title:     string
    yesSymbol: string   // 内部 YES 合约标识，例如 BTC100K-2025-YES
    // 你只维护这一个符号的订单簿
    result:    EventResult
}
```

### 2. 用户在某个事件上的持仓

我们只在撮合后更新这张表。

```pseudo
struct UserEventPosition {
    userId:   long
    eventId:  long

    yesQty:   decimal  // 持有的 YES 张数（只记录净仓位，>=0 简化）
    noQty:    decimal  // 持有的 NO 张数（镜像合成，>=0 简化）

    // 用于算盈亏的成本记录（平均成本或加权成本）
    yesCost:  decimal  // 累计买 YES 花的钱 - 卖 YES 收的钱
    noCost:   decimal  // 累计买 NO 花的钱 - 卖 NO 收的钱
}
```

> 简化假设：
>
> * 不允许裸空（用户不能在没持仓情况下卖 YES / NO），下单前先校验 `yesQty >= qty` 或 `noQty >= qty`。
> * 这样结算逻辑非常干净（全是多头）。

---

## 三、下单入口：统一预测 API → YES 单簿路由

这是你给前端的统一接口：

```pseudo
enum PredictionDirection { HAPPEN, NOT_HAPPEN }
enum OrderSide { BUY, SELL }

// 用户调用的下单接口
function placePredictionOrder(
    userId: long,
    eventId: long,
    direction: PredictionDirection,
    side: OrderSide,
    price: decimal,   // 0~1
    quantity: decimal // 张数
) {
    event = eventRepo.get(eventId)
    assert(event != null)

    // ===== 1. 基于预测方向 + 买卖方向，决定走 YES 簿的什么指令 =====
    // underlyingSide: YES 簿中的方向
    // yesPrice:       YES 簿中的价格
    if direction == HAPPEN {
        // 本质就是 YES
        yesPrice = price
        underlyingSide = side            // BUY/SELL 同向
    } else { // NOT_HAPPEN → NO
        // 镜像价格：p_yes = 1 - p_no
        yesPrice = 1 - price

        // 注意：这里有多种设计方式，
        // 简化版：NO 的买卖在资金/持仓层体现，
        // YES 簿仍按 side 下单
        underlyingSide = oppositeIfYouWantShortLogicOrKeepSame(side)
        // 先给个简单版：也保持同向，
        // 实际精确金融逻辑可单独优化
    }

    // ===== 2. 构造一个 YES 合约订单，交给撮合引擎 =====
    yesOrder = new MatchingOrder()
    yesOrder.userId   = userId
    yesOrder.symbol   = event.yesSymbol
    yesOrder.side     = underlyingSide   // BUY 或 SELL
    yesOrder.price    = yesPrice
    yesOrder.quantity = quantity
    yesOrder.meta = {
        eventId:   eventId,
        direction: direction,  // HAPPEN / NOT_HAPPEN
        userSide:  side,       // 用户视角的 BUY/SELL
        userPrice: price       // 用户输入的价格（YES 或 NO 的价）
    }

    matchingEngine.submitOrder(yesOrder, onFillCallback)
}
```

> `meta` 里保存用户视角的信息，方便成交回调时正确更新 YES/NO 持仓和现金。

`oppositeIfYouWantShortLogicOrKeepSame` 这里我先不玩太复杂的衍生品精算，**伪代码里我们假定：NO 交易也可以用同向下单，资金结算在记账层单独处理**，你后面可以根据是否允许空头、是否要保证金来调优。

---

## 四、撮合成交回调：根据 HAPPEN/NOT_HAPPEN 更新 YES/NO 持仓

撮合引擎只负责 **撮合 YES 合约**，当一笔成交完成时，调用如下回调：

```pseudo
// 撮合引擎在每一笔成交时回调
struct Fill {
    makerUserId: long
    takerUserId: long
    symbol:      string    // yesSymbol
    side:        OrderSide // 对 taker 来说的买/卖方向
    price:       decimal   // YES 成交价
    quantity:    decimal
    takerMeta:   any       // 上面下单时传入的 meta
    makerMeta:   any
}

function onFillCallback(fill: Fill) {
    // 分别更新 maker 和 taker 的持仓 / 现金
    applyFillToUser(fill.makerUserId, fill.price, fill.quantity, fill.makerMeta, makerOrTaker="MAKER")
    applyFillToUser(fill.takerUserId, fill.price, fill.quantity, fill.takerMeta, makerOrTaker="TAKER")
}
```

### `applyFillToUser`：把一笔 YES 成交，解释成 YES 或 NO 的仓位变化

```pseudo
function applyFillToUser(
    userId: long,
    yesFillPrice: decimal,   // YES 的真实成交价
    qty: decimal,
    meta: any,               // 里面有 eventId, direction(H/N), userSide(B/S), userPrice(用户报价)
    makerOrTaker: string
) {
    eventId   = meta.eventId
    direction = meta.direction   // HAPPEN / NOT_HAPPEN
    userSide  = meta.userSide    // BUY / SELL
    userPrice = meta.userPrice   // 用户输入的 YES 或 NO 价格

    pos = positionRepo.getOrCreate(userId, eventId)
    cash = accountRepo.getOrCreateCashAccount(userId)

    if direction == HAPPEN {
        // ========== 用户在玩 YES ==========
        if userSide == BUY {
            // 买 YES：扣现金，增 YES 仓位
            effectivePrice = yesFillPrice      // 你也可以用滑点后真实价，而非 userPrice
            cash.balance -= effectivePrice * qty

            pos.yesQty   += qty
            pos.yesCost  += effectivePrice * qty
        } else { // SELL YES
            effectivePrice = yesFillPrice
            // 简化：只允许在有仓位时卖出
            assert(pos.yesQty >= qty)

            cash.balance += effectivePrice * qty

            pos.yesQty   -= qty
            pos.yesCost  -= proportionalCost(pos.yesCost, pos.yesQty, qty)
        }
    } else {
        // ========== 用户在玩 NO ==========
        // NO 的有效成交价可以用镜像：p_no = 1 - p_yes_fill
        effectiveNoPrice = 1 - yesFillPrice

        if userSide == BUY {
            // 买 NO：扣现金，增 NO 仓位
            cash.balance -= effectiveNoPrice * qty

            pos.noQty    += qty
            pos.noCost   += effectiveNoPrice * qty
        } else { // SELL NO
            assert(pos.noQty >= qty)

            cash.balance += effectiveNoPrice * qty

            pos.noQty    -= qty
            pos.noCost   -= proportionalCost(pos.noCost, pos.noQty, qty)
        }
    }

    positionRepo.save(pos)
    accountRepo.save(cash)
}
```

> `proportionalCost(...)` 用来做加权平均成本的拆分，可以实现为：“先算平均成本，再乘以卖掉的数量”。

**重点：**

* 撮合引擎只知道 YES 成交价与方向；
* 你在 `applyFillToUser` 里，用 `direction(HAPPEN/NOT_HAPPEN)` + `1 - yesPrice` 做镜像，来更新 **YES/NO 多头仓位**；
* 这样 **YES 只用一个订单簿，NO 完全是账户层的“合成资产”。**

---

## 五、查询持仓：一个事件下的 YES/NO 仓位 + 最大盈亏

```pseudo
struct PositionView {
    eventId: long
    yesQty:  decimal
    yesAvgPrice: decimal
    noQty:   decimal
    noAvgPrice:  decimal

    // 一些方便展示的衍生字段
    maxPayoutIfYes: decimal
    maxPayoutIfNo:  decimal
}

function getUserEventPositionView(userId: long, eventId: long) -> PositionView {
    pos = positionRepo.get(userId, eventId)
    if pos == null:
        return zeroPositionView(eventId)

    yesAvg = (pos.yesQty > 0) ? (pos.yesCost / pos.yesQty) : 0
    noAvg  = (pos.noQty  > 0) ? (pos.noCost  / pos.noQty)  : 0

    view = new PositionView()
    view.eventId      = eventId
    view.yesQty       = pos.yesQty
    view.yesAvgPrice  = yesAvg
    view.noQty        = pos.noQty
    view.noAvgPrice   = noAvg

    // 最简单的最大赔付（忽略手续费）：
    // 事件结果 YES：每张 YES 付 1，每张 NO 付 0
    view.maxPayoutIfYes = pos.yesQty * 1
    view.maxPayoutIfNo  = pos.noQty * 1

    return view
}
```

前端可以用：

* 当前 YES 市场价 `p_yes`

  * 浮盈 YES ≈ `(1 - yesAvgPrice) * yesQty * p_implied_if_yes` 等你自定义
* 当前 NO 隐含价 `p_no = 1 - p_yes`

这些都可以自由组合。

---

## 六、事件结算：根据结果一次性发钱

当 Oracle 或管理员公布事件结果时（YES / NO），你做一次结算：

```pseudo
function settleEvent(eventId: long, result: EventResult) {
    event = eventRepo.get(eventId)
    assert(event.result == UNKNOWN)   // 只结一次

    // 找出所有在该事件有持仓的用户
    allPositions = positionRepo.listByEvent(eventId)

    for pos in allPositions {
        userId = pos.userId
        cash   = accountRepo.getOrCreateCashAccount(userId)

        if result == YES {
            // YES 赢：每张 YES 兑 1，NO 兑 0
            payout = pos.yesQty * 1.0
        } else if result == NO {
            // NO 赢：每张 NO 兑 1，YES 兑 0
            payout = pos.noQty * 1.0
        } else {
            // INVALID 或流盘，可自定义逻辑：
            // 比如全部退本金（按成本退回）
            payout = pos.yesCost + pos.noCost
        }

        cash.balance += payout

        // 清仓（或保留历史记录，另存一张历史表）
        pos.yesQty  = 0
        pos.noQty   = 0
        pos.yesCost = 0
        pos.noCost  = 0

        accountRepo.save(cash)
        positionRepo.save(pos)
    }

    event.result = result
    eventRepo.save(event)
}
```

> 这里我用了 **最简单版本**：
>
> * 不考虑杠杆 / 空头 / 保证金；
> * 只有“买入 YES/NO 得多头仓位，结算时按 1 或 0 支付”；
> * 卖出只是平掉已有仓位（不能裸空）。

你之后如果需要支持 **裸空 / 做市商 / 保证金**，可以在 `applyFillToUser` 和 `settleEvent` 里加保证金和负余额逻辑。

---

## 七、整体思路再帮你压缩成一句话

> **撮合层：**
> 只维护一个 YES 订单簿，像普通现货一样撮合。

> **路由层：**
> 用户的 YES/NO 指令 → 转成 YES 簿的订单（价格镜像：`p_yes=1-p_no`）。

> **账户层：**
> 通过 `direction(HAPPEN/NOT_HAPPEN)` + `1 - yesFillPrice` 把成交转换成 YES/NO 持仓 & 现金变化。

> **结算层：**
> 事件结果 YES：只兑 YES 仓位；
> 事件结果 NO：只兑 NO 仓位。

---

如果你愿意，下一步我可以：

* 帮你把这一整套伪代码改写成 **Go 版本**（贴近你现在的后端风格），
* 或者直接给你画出一张 **“事件下单 → YES 簿撮合 → 仓位更新 → 结算”的时序图**，方便你贴到设计文档里。




好，我们把 **“单 YES 订单簿 + NO 镜像” 的完整数据库结构** 一次性设计出来，你可以直接贴进 PostgreSQL / MySQL 做基础版实现。

我按模块来：

1. 事件 & 标的（Event / Instrument）
2. 账户 & 余额（User / Balance / Ledger）
3. 下单 & 撮合（Order / Trade）
4. 预测仓位（YES/NO 持仓）
5. 结算记录（Settlement）

字段名尽量工程化，注释里我用中英混合。

---

## 1️⃣ 事件 & 标的：`pm_event` + `pm_instrument`

> 一个事件（YES/NO），只创建一个 **YES 标的**，订单簿只挂 YES。
> NO 完全在持仓层镜像出来。

```sql
-- 预测事件：比如 “BTC 是否在 2025-12-31 前 > 100k？”
CREATE TABLE pm_event (
    id               BIGSERIAL PRIMARY KEY,
    symbol           VARCHAR(64)  NOT NULL,  -- 事件唯一代号，如 BTC100K-20251231
    title            VARCHAR(255) NOT NULL,  -- 展示标题
    description      TEXT,

    base_asset       VARCHAR(32)  NOT NULL DEFAULT 'USDC', -- 结算币种

    start_trading_at TIMESTAMP    NOT NULL,  -- 开盘时间
    end_trading_at   TIMESTAMP    NOT NULL,  -- 停盘时间（通常事件开始前）
    resolve_at       TIMESTAMP,              -- 预期结算时间

    status           VARCHAR(32)  NOT NULL,  -- DRAFT/OPEN/CLOSED/RESOLVING/SETTLED/CANCELED
    result           VARCHAR(16),            -- UNKNOWN/YES/NO/INVALID

    yes_instrument_id BIGINT,               -- 指向 pm_instrument.id（YES 标的）
    oracle_source    VARCHAR(64),           -- oracle 来源，如 admin/chainlink
    oracle_ref       VARCHAR(128),          -- 外部 ID 或 URL

    created_at       TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at       TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_pm_event_symbol ON pm_event(symbol);
```

```sql
-- 交易标的：这里只为每个事件创建一个 YES 标的
CREATE TABLE pm_instrument (
    id             BIGSERIAL PRIMARY KEY,
    event_id       BIGINT NOT NULL REFERENCES pm_event(id),

    symbol         VARCHAR(64)  NOT NULL,  -- 如 BTC100K-20251231-YES
    name           VARCHAR(128) NOT NULL,  -- 展示名：BTC>100k-YES

    tick_size      NUMERIC(18,8) NOT NULL DEFAULT 0.01, -- 报价精度
    min_qty        NUMERIC(18,8) NOT NULL DEFAULT 1,
    max_qty        NUMERIC(18,8),

    maker_fee_rate NUMERIC(10,8) NOT NULL DEFAULT 0.0002,
    taker_fee_rate NUMERIC(10,8) NOT NULL DEFAULT 0.0005,

    status         VARCHAR(32) NOT NULL DEFAULT 'OPEN', -- OPEN/PAUSED/SETTLED

    created_at     TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_pm_instrument_symbol ON pm_instrument(symbol);
```

> 联动：
>
> * 每个 `pm_event` 只对应一个 `pm_instrument(YES)`
> * `pm_event.yes_instrument_id` 填上去，方便查询。

---

## 2️⃣ 用户 & 余额：`pm_user_balance` + `pm_ledger`

你可以直接复用你现有的钱包表结构，这里给预测模块用的简单版。

```sql
-- 用户在预测系统中的币种余额（这里主要是 USDC）
CREATE TABLE pm_user_balance (
    id           BIGSERIAL PRIMARY KEY,
    user_id      BIGINT      NOT NULL,
    asset        VARCHAR(32) NOT NULL,               -- 如 'USDC'
    available    NUMERIC(36,18) NOT NULL DEFAULT 0,  -- 可用余额
    locked       NUMERIC(36,18) NOT NULL DEFAULT 0,  -- 冻结（挂单占用等）

    updated_at   TIMESTAMP NOT NULL DEFAULT NOW(),

    UNIQUE (user_id, asset)
);
```

```sql
-- 资金流水（可选：若你已有全局 ledger，可以只加 biz_type=prediction）
CREATE TABLE pm_ledger (
    id           BIGSERIAL PRIMARY KEY,
    user_id      BIGINT      NOT NULL,
    asset        VARCHAR(32) NOT NULL,
    change_amount NUMERIC(36,18) NOT NULL, -- 正数入账，负数出账
    balance_after NUMERIC(36,18) NOT NULL,

    biz_type     VARCHAR(32) NOT NULL,     -- ORDER_FREEZE/ORDER_RELEASE/TRADE/FEE/SETTLEMENT...
    biz_id       BIGINT,                   -- 对应 order_id, trade_id 或 settlement_id 等
    remark       TEXT,

    created_at   TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_pm_ledger_user_time ON pm_ledger(user_id, created_at);
```

---

## 3️⃣ 订单 & 成交：`pm_order` + `pm_trade`

> 撮合引擎只维护 **YES 合约** 的订单簿。
> 用户下“NO 方向单”时，在业务层镜像转换为 YES 的挂单。

```sql
-- 单 YES 订单簿中的订单记录
CREATE TABLE pm_order (
    id               BIGSERIAL PRIMARY KEY,
    client_order_id  VARCHAR(64),                 -- 前端自定义ID（可选）
    user_id          BIGINT      NOT NULL,

    event_id         BIGINT      NOT NULL REFERENCES pm_event(id),
    instrument_id    BIGINT      NOT NULL REFERENCES pm_instrument(id),

    -- 用户视角
    prediction_dir   VARCHAR(16) NOT NULL,        -- 'HAPPEN' / 'NOT_HAPPEN'
    prediction_side  VARCHAR(4)  NOT NULL,        -- 'BUY' / 'SELL'

    -- 底层 YES 簿视角
    book_side        VARCHAR(4)  NOT NULL,        -- 'BUY' / 'SELL' (YES 的方向)
    book_price       NUMERIC(18,8) NOT NULL,      -- YES 的真实价格（0~1）

    -- 用户输入的价格（方便前端展示、风控）
    user_price       NUMERIC(18,8) NOT NULL,      -- 用户看到的价格（YES 或 NO 价）

    type             VARCHAR(16) NOT NULL,        -- LIMIT/MARKET
    time_in_force    VARCHAR(16) NOT NULL DEFAULT 'GTC',

    quantity         NUMERIC(18,8) NOT NULL,      -- 下单张数
    filled_quantity  NUMERIC(18,8) NOT NULL DEFAULT 0,
    avg_fill_price   NUMERIC(18,8),

    status           VARCHAR(16) NOT NULL,        -- NEW/PARTIAL/FILLED/CANCELED/REJECTED

    created_at       TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at       TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_pm_order_event ON pm_order(event_id);
CREATE INDEX idx_pm_order_user  ON pm_order(user_id);
CREATE INDEX idx_pm_order_inst  ON pm_order(instrument_id);
```

```sql
-- 成交记录（YES 合约），NO 的价格通过镜像 p_no = 1 - p_yes
CREATE TABLE pm_trade (
    id               BIGSERIAL PRIMARY KEY,

    event_id         BIGINT NOT NULL REFERENCES pm_event(id),
    instrument_id    BIGINT NOT NULL REFERENCES pm_instrument(id),

    taker_order_id   BIGINT NOT NULL REFERENCES pm_order(id),
    maker_order_id   BIGINT NOT NULL REFERENCES pm_order(id),

    taker_user_id    BIGINT NOT NULL,
    maker_user_id    BIGINT NOT NULL,

    -- YES 维度的成交
    yes_price        NUMERIC(18,8) NOT NULL,
    quantity         NUMERIC(18,8) NOT NULL,
    taker_side       VARCHAR(4) NOT NULL,          -- 对 taker 来说，BUY/SELL (YES)

    -- 手续费
    taker_fee        NUMERIC(18,8) NOT NULL DEFAULT 0,
    maker_fee        NUMERIC(18,8) NOT NULL DEFAULT 0,

    created_at       TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_pm_trade_event ON pm_trade(event_id, created_at);
CREATE INDEX idx_pm_trade_user  ON pm_trade(taker_user_id);
```

> 后面在业务层的回调里，用 `yes_price` 做：
>
> * YES 方向：直接用
> * NO 方向：`no_price = 1 - yes_price` 转换，用于记账与持仓。

---

## 4️⃣ 预测仓位：`pm_user_event_position`（YES/NO 持仓镜像）

> 这一张表是“**预测市场的核心账户层**”：
>
> * 只按 **事件维度** 汇总持仓
> * YES/NO 都叫“仓位”，结算时按结果发钱

```sql
CREATE TABLE pm_user_event_position (
    id          BIGSERIAL PRIMARY KEY,

    user_id     BIGINT NOT NULL,
    event_id    BIGINT NOT NULL REFERENCES pm_event(id),

    -- 净多头张数 >= 0（简化模型：不支持裸空）
    yes_qty     NUMERIC(18,8) NOT NULL DEFAULT 0,  -- 持有的 YES 张数
    no_qty      NUMERIC(18,8) NOT NULL DEFAULT 0,  -- 持有的 NO 张数

    -- 成本记录（可用来算平均成本和已实现盈亏）
    yes_cost    NUMERIC(36,18) NOT NULL DEFAULT 0, -- 累计买入成本-卖出回收
    no_cost     NUMERIC(36,18) NOT NULL DEFAULT 0,

    realized_pnl NUMERIC(36,18) NOT NULL DEFAULT 0, -- 已实现盈亏（可选）

    updated_at  TIMESTAMP NOT NULL DEFAULT NOW(),

    UNIQUE (user_id, event_id)
);

CREATE INDEX idx_pm_pos_event ON pm_user_event_position(event_id);
CREATE INDEX idx_pm_pos_user  ON pm_user_event_position(user_id);
```

> 撮合回调时，你会根据订单的 `prediction_dir`（HAPPEN/NOT_HAPPEN） + `taker_side/maker_side`：

* 更新 `yes_qty/yes_cost`（玩 YES）
* 更新 `no_qty/no_cost`（玩 NO，通过 `no_price = 1 - yes_price` 镜像计算）

---

## 5️⃣ 结算记录：`pm_event_settlement`

> 事件有唯一结算记录，执行时遍历所有 `pm_user_event_position` 对该事件进行兑付。

```sql
CREATE TABLE pm_event_settlement (
    id               BIGSERIAL PRIMARY KEY,
    event_id         BIGINT NOT NULL REFERENCES pm_event(id),

    result           VARCHAR(16) NOT NULL,   -- YES/NO/INVALID
    resolved_at      TIMESTAMP   NOT NULL,
    resolver         VARCHAR(64),            -- 谁触发的结算（admin/oracle）
    tx_hash          VARCHAR(128),           -- 若有链上结算，可存 tx
    note             TEXT,

    created_at       TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_pm_event_settle_unique ON pm_event_settlement(event_id);
```

结算 pseudo 逻辑（对应这张表结构）：

* `result = YES`：

  * 每人拿 `yes_qty * 1 USDC`
* `result = NO`：

  * 每人拿 `no_qty * 1 USDC`
* `result = INVALID`：

  * 可选择退回 `yes_cost + no_cost`（本金模式）

---

## ✅ 总结一下各表职责（方便你在脑中串起来）

* **pm_event**：
  一个预测事件（YES/NO），例如 *BTC>100K-20251231*

* **pm_instrument**：
  该事件对应的 YES 合约标的（订单簿只挂它）

* **pm_order / pm_trade**：
  撮合层所有东西都是 YES 方向的，NO 完全在记账/持仓上镜像

* **pm_user_balance / pm_ledger**：
  用户 USDC 资金；下单冻结、成交扣款、结算入账，都记录在这里

* **pm_user_event_position**：
  每个用户在每个事件上的预测仓位：`yes_qty/no_qty` + 成本
  ✔ 这是结算时要看的核心表

* **pm_event_settlement**：
  事件结算记录（YES/NO/INVALID），可以多链/多系统对账用

---

如果你愿意，下一步可以选一个方向我继续往下：

1. 把这些表串成一条完整“**下单 → 撮合 → 更新余额/仓位 → 事件结算 → 发钱**”的 **事务流程图 / 时序图**；
2. 帮你写一套 **真实的 SQL + Service 层伪代码**（比如 `settleEvent()`、`applyFillToUser()` 对这些表怎么 UPDATE）；
3. 按你现在的交易系统（如果你有现成 order/trade 表）帮你做一份 **“最小改动整合方案”**。
