

---

## 一、订单簿预测市场的「统一盘口」设计图

**目标：**

* 底层：YES / NO 各自一套订单簿（和现有撮合系统兼容）
* 上层：给用户展示的是一个**统一事件盘口**：

  * 买「会发生」
  * 卖「会发生」
  * 买「不会发生」
  * 卖「不会发生」

### 1. 结构示意（逻辑图）

```text
                 ┌────────────────────────┐
                 │   Event Market View    │   ← 用户只看到这一层
                 │  事件：BTC>100k？      │
                 │                        │
                 │  Bid/Ask (HAPPEN)      │
                 │  Bid/Ask (NOT HAPPEN)  │
                 └─────────┬──────────────┘
                           │ 智能路由 + 映射
           ┌───────────────┴─────────────────┐
           │                                   │
┌──────────────────────┐           ┌──────────────────────┐
│ YES Contract Orderbook│          │  NO Contract Orderbook│
│ 合约：BTC>100k-YES    │          │ 合约：BTC>100k-NO     │
│  买单/卖单            │          │  买单/卖单             │
└──────────────────────┘          └──────────────────────┘
```

### 2. 用户视角的「统一盘口」

统一盘口可以长这样（对用户）：

```text
事件：BTC 在 12/31 前是否 > 100k？

[会发生 HAPPEN]
  买盘(Bid)：价格/数量      实际走向
   0.62   300              → YES, BUY
   0.60  1000              → YES, BUY

  卖盘(Ask)：
   0.65   200              → YES, SELL
   0.68   500              → YES, SELL

[不会发生 NOT HAPPEN]
  买盘(Bid)：
   0.38   600              → NO, BUY
   0.35  1200              → NO, BUY

  卖盘(Ask)：
   0.40   300              → NO, SELL
   0.42   800              → NO, SELL
```

**底层映射关系：**

* 区块「会发生」

  * 买 = BUY YES
  * 卖 = SELL YES
* 区块「不会发生」

  * 买 = BUY NO
  * 卖 = SELL NO

也可以只展示「会发生」一边，另一边用隐含价格 `1 - P_yes` 衍生出来（更接近 AMM 体验）。

---

## 二、YES/NO 智能路由逻辑（伪代码 + 简单公式）

### 1. 基本映射逻辑

先定义：

```text
Event e:
  - yes_contract_id
  - no_contract_id
```

统一接口（给前端）：

```text
placePredictionOrder(
    event_id,
    direction,   // HAPPEN / NOT_HAPPEN
    side,        // BUY / SELL
    price,
    quantity
)
```

#### 路由伪代码（最基础版）

```pseudo
function placePredictionOrder(eventId, direction, side, price, quantity, userId):
    event = loadEvent(eventId)

    if direction == HAPPEN:
        contractId = event.yes_contract_id
    else if direction == NOT_HAPPEN:
        contractId = event.no_contract_id
    else:
        throw "invalid direction"

    // side BUY/SELL 直接沿用
    order = {
        user_id: userId,
        contract_id: contractId,
        side: side,         // BUY / SELL
        price: price,       // 0~1 之间的 USDC 价格
        quantity: quantity, // 张数，每张上限 1 USDC
        type: LIMIT
    }

    sendToMatchingEngine(order)
```

**核心点：**
统一预测接口 → 映射到 YES / NO 具体合约 → 丢给你现有的撮合引擎。

---

### 2. 展示隐含价格（YES/NO 互推）

如果你希望统一盘口只显示 YES 价格，同时给出 NO 的隐含信息：

```text
P_yes_best = YES 市场当前最优价（例如 best_ask 或 mid）
P_no_implied = 1 - P_yes_best
```

或者更严格一点，加一个边际 ε：

```text
P_no_implied = max(0, 1 - P_yes_best - ε)
```

> ε 是给套利者留一点空间，避免理论上死锁。

---

### 3. （可选进阶）跨簿套利/对冲的路由逻辑

如果你希望系统自动「聪明一点」：

**目标：**
用户下单时，优先吃掉「另一边明显错价」的 liquidity，让系统帮用户自动套利。

示例：用户想买「不会发生」（NO, BUY）：

```pseudo
function routeBuyNotHappen(eventId, price, qty, userId):
    event = loadEvent(eventId)
    yesBook = getOrderbook(event.yes_contract_id)
    noBook  = getOrderbook(event.no_contract_id)

    // 1. 先看 NO 订单簿能否直接吃单
    bestNoAsk = noBook.bestAsk()  // NO 的最优卖价

    if bestNoAsk <= price:
        // 直接在 NO 簿成交 (taker)
        matchInOrderbook(noBook, BUY, price, qty, userId)
        return

    // 2. 看 YES 是否明显错价，例如 YES+NO > 1 的情况
    bestYesBid = yesBook.bestBid()

    // 强套利条件（例子，实际可调）：
    if bestYesBid + price > 1 + epsilon:
        // 系统可以作为中间商做一笔锁定套利
        // (用户买 NO @ price，系统在 YES 簿卖出或买入对冲)
        syntheticArbTrade(userId, event, price, qty)
        return

    // 3. 否则，挂为 NO 的买单
    placeLimitOrder(event.no_contract_id, BUY, price, qty, userId)
```

这部分可以根据你愿不愿意让「系统扮演做市商」来决定，要不要实现。
你也可以完全不做跨簿自动套利，而是放给专业用户做。

---

## 三、CLOB 下的预测事件产品结构（数据库表）

下面给一套可直接用的 SQL 表结构（偏交易所风格），你可以融合进你现有撮合系统。

### 1. 事件表：`t_event`

```sql
CREATE TABLE t_event (
    id               BIGSERIAL PRIMARY KEY,
    symbol           VARCHAR(64) NOT NULL,  -- 例如 BTC100K-20251231
    title            VARCHAR(255) NOT NULL, -- 展示标题
    description      TEXT,
    base_asset       VARCHAR(32) NOT NULL DEFAULT 'USDC',

    start_trading_at TIMESTAMP NOT NULL,    -- 开盘时间
    end_trading_at   TIMESTAMP NOT NULL,    -- 停盘时间（事件开始前）
    resolve_at       TIMESTAMP,             -- 预期结算时间

    status           VARCHAR(32) NOT NULL,  -- PENDING/OPEN/RESOLVING/SETTLED/CANCELED
    result           VARCHAR(16),           -- YES/NO/INVALID/UNRESOLVED

    yes_contract_id  BIGINT,                -- 方便查询
    no_contract_id   BIGINT,

    oracle_source    VARCHAR(64),           -- 预言机来源，如 "admin", "chainlink"
    oracle_ref       VARCHAR(128),          -- 外部ID、URL等

    created_at       TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at       TIMESTAMP NOT NULL DEFAULT NOW()
);
```

---

### 2. 合约表（YES/NO 合约）：`t_contract`

```sql
CREATE TABLE t_contract (
    id             BIGSERIAL PRIMARY KEY,
    event_id       BIGINT NOT NULL REFERENCES t_event(id),

    side           VARCHAR(8) NOT NULL,     -- 'YES' 或 'NO'
    symbol         VARCHAR(64) NOT NULL,    -- 如 BTC100K-20251231-YES
    display_name   VARCHAR(128),            -- 前端展示名

    tick_size      NUMERIC(18,8) NOT NULL DEFAULT 0.01,  -- 价格精度
    min_qty        NUMERIC(18,8) NOT NULL DEFAULT 1,
    max_qty        NUMERIC(18,8),

    maker_fee_rate NUMERIC(10,8) NOT NULL DEFAULT 0.0002,
    taker_fee_rate NUMERIC(10,8) NOT NULL DEFAULT 0.0005,

    status         VARCHAR(32) NOT NULL DEFAULT 'OPEN',  -- OPEN/PAUSED/SETTLED
    settlement_price NUMERIC(18,8),        -- 1, 0 或 0.5（INVALID）

    created_at     TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at     TIMESTAMP NOT NULL DEFAULT NOW()
);
```

> 对一个事件，会有两条记录：
> `side='YES'` 和 `side='NO'`。
> `event.yes_contract_id` / `event.no_contract_id` 指向它们。

---

### 3. 订单表：`t_order`

你可以直接沿用现有撮合系统的 order 表，这里给个通用版：

```sql
CREATE TABLE t_order (
    id               BIGSERIAL PRIMARY KEY,
    client_order_id  VARCHAR(64),                 -- 前端生成，选填
    user_id          BIGINT NOT NULL,

    contract_id      BIGINT NOT NULL REFERENCES t_contract(id),

    side             VARCHAR(4) NOT NULL,         -- 'BUY' / 'SELL'
    type             VARCHAR(16) NOT NULL,        -- 'LIMIT'/'MARKET' 等
    time_in_force    VARCHAR(16) NOT NULL DEFAULT 'GTC',

    price            NUMERIC(18,8),               -- LIMIT单有效
    quantity         NUMERIC(18,8) NOT NULL,      -- 下单总量
    filled_quantity  NUMERIC(18,8) NOT NULL DEFAULT 0,
    avg_fill_price   NUMERIC(18,8),

    status           VARCHAR(16) NOT NULL,        -- NEW/PARTIAL/FILLED/CANCELED/REJECTED

    created_at       TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at       TIMESTAMP NOT NULL DEFAULT NOW()
);
```

---

### 4. 成交表：`t_trade`

```sql
CREATE TABLE t_trade (
    id               BIGSERIAL PRIMARY KEY,
    contract_id      BIGINT NOT NULL REFERENCES t_contract(id),

    taker_order_id   BIGINT NOT NULL REFERENCES t_order(id),
    maker_order_id   BIGINT NOT NULL REFERENCES t_order(id),

    taker_user_id    BIGINT NOT NULL,
    maker_user_id    BIGINT NOT NULL,

    price            NUMERIC(18,8) NOT NULL,
    quantity         NUMERIC(18,8) NOT NULL,
    taker_side       VARCHAR(4) NOT NULL,         -- BUY/SELL

    taker_fee        NUMERIC(18,8) NOT NULL DEFAULT 0,
    maker_fee        NUMERIC(18,8) NOT NULL DEFAULT 0,

    created_at       TIMESTAMP NOT NULL DEFAULT NOW()
);
```

---

### 5. 持仓/仓位表：`t_position`

```sql
CREATE TABLE t_position (
    id               BIGSERIAL PRIMARY KEY,
    user_id          BIGINT NOT NULL,
    contract_id      BIGINT NOT NULL REFERENCES t_contract(id),

    quantity         NUMERIC(18,8) NOT NULL,      -- 持有张数, BUY 为正, SELL 可以视为负或保持独立字段
    avg_entry_price  NUMERIC(18,8) NOT NULL DEFAULT 0,

    realized_pnl     NUMERIC(18,8) NOT NULL DEFAULT 0,

    updated_at       TIMESTAMP NOT NULL DEFAULT NOW(),

    UNIQUE (user_id, contract_id)
);
```

---

### 6. 结算记录表：`t_event_settlement`

```sql
CREATE TABLE t_event_settlement (
    id               BIGSERIAL PRIMARY KEY,
    event_id         BIGINT NOT NULL REFERENCES t_event(id),
    result           VARCHAR(16) NOT NULL,       -- YES/NO/INVALID
    resolved_at      TIMESTAMP NOT NULL,
    tx_hash          VARCHAR(128),              -- 若链上结算，可存交易哈希
    note             TEXT
);
```

结算时：

1. 更新 `t_event.result` / `t_contract.settlement_price`（YES=1, NO=0 或反之）
2. 遍历 `t_position` 按持仓发放结算资金（USDC）
3. 记录一条 `t_event_settlement`

---

## 小结

你要的三块现在已经成型：

1. **统一盘口设计图**

   * 用户只看到「事件盘口」，底层 YES/NO 各一套订单簿
   * 智能路由负责把预测指令翻译为具体合约订单

2. **YES/NO 智能路由逻辑（伪代码+公式）**

   * `direction(HAPPEN/NOT_HAPPEN)` → `yes_contract_id/no_contract_id`
   * 支持扩展到跨簿套利/系统做市

3. **CLOB 下预测事件产品结构（SQL 表）**

   * `t_event` 事件
   * `t_contract` YES/NO 合约
   * `t_order` / `t_trade` / `t_position` / `t_event_settlement`

---

如果你愿意，下一步我可以帮你做其中任意一个的「**代码级实现**」：

* 用 **Go** 写一个极简撮合引擎（内存订单簿 + 预测事件支持）
* 或者直接帮你把这些 SQL + 路由逻辑整合进你现在的撮合/钱包/清算系统设计里。

你下一步想先搞：**撮合引擎 demo** 还是 **结算/清算流程设计**？
